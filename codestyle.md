# Некоторые чек-листы для лаб aka codestyle

## Основное

Основой кода стайла является [Google C++ Code Style Guide](https://google.github.io/styleguide/cppguide.html)

Для форматирования лучше настроить [clang-tidy](https://clang.llvm.org/extra/clang-tidy/Integrations.html)

## 1.Общие правила

1. У нас принят CamelCase для именования функций и классов, но сеттеры и геттеры можно именовать как переменные, начиная с маленькой буквы. ([Google Style Guide](https://google.github.io/styleguide/cppguide.html#Function_Names)).
2. using namespace запрещён. Если очень нужно, сделайте псевдоним с помощью namespace a = f::d::e; ([Google Style Guide](https://google.github.io/styleguide/cppguide.html#Namespaces))
3. Если в cpp-файле есть класс или функция, которые используются только в этом файле, они должны быть помещены в анонимный namespace ([Google Style Guide](https://google.github.io/styleguide/cppguide.html#Unnamed_Namespaces_and_Static_Variables)). Если анонимный namespace разрастается до сотен строк, стоит подумать над тем, чтобы вынести код в hpp-cpp пару(-ы).
4. Всё, что может быть const, должно быть const: ссылочные аргументы, локальные переменные, методы и поля класса.
[Google Style Guide](https://google.github.io/styleguide/cppguide.html#Use_of_const)
5. Если функция не обращается к нестатическим атрибутам объекта и не предполагает перегрузки в наследниках (например для тестирования), она должна быть статической. Если все функции класса статические, нужно заменить такой класс на namespace.
6. Если строковая константа используется более двух раз, нужно вынести её в константную переменную. Если используется в одном файле, объявить её в анонимном неймспейсе в этом же файле, если в разных, то вынести в соответствующий файл `names.hpp`.
7. Если виртуальная функция переопределяется в классе-потомке, она должна иметь спецификатор `override` или `final`.
8. Нельзя бросать исключения из деструктора.
9. Не использовать исключения для control flow, использовать только для ошибочных ситуаций.
10. Не добавлять в заголовочные файлы лишние зависимости, особенно если этот хедер часто используется. Это сильно замедляет сборку и пересборку.
11. По возможности реализовывать функции и методы в cpp файлах
12. Стараться явно прописывать хедеры, которые используются в данном файле. Если какой-то хедер нужен только для имплементации, убрать его включение в cpp файл. А в заголовочном файле добавить необходимые forward declaration'ы.
13. Не захватываем в lambda все объекты по ссылке.
14. При передаче enum с фиксированным набором значений в switch, метка default не добавляется.
16. Если указатель не может быть `nullptr`, то его нужно сделать ссылкой.

## 2. Specific cases

1. Всё содержимое библиотеки должно принадлежать одноимённому неймспейсу. К примеру, типы и функции библиотеки `geometry` должны находиться в неймспейсе `geometry`.
2. Неймспейс соответствует файлу, в котором он находится. К примеру, в файле `service_name/models/mongo/x.hpp` всё содержимое должно находиться в неймспейсе `service_name::models::mongo` (`::library_name::models::mongo` для библиотек).
3. `catch (...)` запрещён, если вы не прокидываете исключение дальше. Но лучше не ловить совсем и обходиться RAII. Используйте `catch (const std::exception&)` (а лучше писать свои исключения, чтобы ловить только их)
4. Согласно google style guide, группируем инклюды в следующие группы (группа = последовательность инклюдов, ограниченная пустой строкой в начале и в конце):
    1. один парный хедер
    2. хедеры стандартной библиотеки
    3. хедеры внешних библиотек (например, `gtest`)
    4. хедеры библиотек, которые не относятся к текущему проекту
    5. хедеры текущий библиотеки/программы
5. Запрещается использовать относительный путь в `#include`. Для этого необходимо пользоваться флагами компиляции/средствами сборки.
6. Вместо `#ifndef ... #define ... #endif` guard использовать `#pragma once`.